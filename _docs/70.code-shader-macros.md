---
title: "Macros for Code Shaders"
permalink: /code-shader-macros/
excerpt: "Macros for Code Shaders (Cg, HLSL)"
---

## Overview

Chroma provides a set of macros that you can use in your code shaders. These macros are used to sample gradients, curves and other Chroma-specific properties.

## Usage

To use Chroma's macros, you need to include the `Chroma.hlsl` file in your shader. This file is located in the `Chroma` package in the `Chroma/Core/HLSL` folder. It is automatically imported when you install Chroma.

To include the file, add the following line to the top of your shader:

```hlsl
#include "Chroma/Core/HLSL/Chroma.hlsl"
```

## Macros

### Gradients

**GRADIENT**

The `GRADIENT` macro is used to declare a gradient in a shader. Under the hood this macro introduces a texture and a sampler. Here is an example:

```hlsl
Properties
{
    [Gradient] _MyGradient("My Gradient", 2D) = "white" {}
}

GRADIENT(_MyGradient)
```

---

**SAMPLE_GRADIENT**

The `SAMPLE_GRADIENT` macro allows you to sample a gradient. It has the following signature:

```hlsl
float4 SAMPLE_GRADIENT(
    float4 gradientProperty,
    float t
)
```

`gradientProperty` is the Chroma gradient property you want to sample. It can be a normal gradient, a rainbow gradient or a random gradient. `t` is the time parameter. It can be a value between 0 and 1 or a value between 0 and `gradientProperty.w`.

---

**SAMPLE_GRADIENT_X**

The `SAMPLE_GRADIENT_X` macro allows you to sample a gradient, specifiying a [`sampler2D`](https://docs.unity3d.com/Manual/SL-SamplerStates.html) to use. It has the following signature:

```hlsl
float4 SAMPLE_GRADIENT_X(
    float4 gradientProperty,
    sampler2D gradientSampler,
    float t
)
```

---

**SAMPLE_GRADIENT_HDR**

The `SAMPLE_GRADIENT_HDR` macro allows you to sample an HDR gradient (TODO: link). It has the same signature as `SAMPLE_GRADIENT`:

```hlsl
float4 SAMPLE_GRADIENT_HDR(
    float4 gradientProperty,
    float t
)
```

---

**SAMPLE_GRADIENT_HDR_X**

The `SAMPLE_GRADIENT_HDR_X` macro allows you to sample an HDR gradient, specifiying a [`sampler2D`](https://docs.unity3d.com/Manual/SL-SamplerStates.html) to use. It has the same signature as `SAMPLE_GRADIENT_X`:

```hlsl
float4 SAMPLE_GRADIENT_HDR_X(
    float4 gradientProperty,
    sampler2D gradientSampler,
    float t
)
```

---

### Curves

**CURVE**

The `CURVE` macro is used to declare a curve in a shader. Under the hood this macro introduces a texture and a sampler. Here is an example:

```hlsl
Properties
{
    [Curve] _MyCurve("My Curve", 2D) = "white" {}
}

CURVE(_MyCurve)
```

---

**SAMPLE_CURVE**

The `CHROMA_SAMPLE_CURVE` macro allows you to sample a curve. It has the following signature:

```hlsl
float CHROMA_SAMPLE_CURVE(
    float4 curveProperty,
    float t
)
```

`curveProperty` is the Chroma curve property you want to sample. `t` is the time parameter. It can be a value between 0 and 1 or a value between 0 and `curveProperty.w`.

`SAMPLE_CURVE_X`{: style="color:gray; font-size: 80%; text-align: center;"}

The `CHROMA_SAMPLE_CURVE_X` macro allows you to sample a curve, specifiying a [`sampler2D`](https://docs.unity3d.com/Manual/SL-SamplerStates.html) to use. It has the following signature:

```hlsl
float CHROMA_SAMPLE_CURVE_X(
    float4 curveProperty,
    sampler2D curveSampler,
    float t
)
```

---

## Example

The following example shows how to use the gradients and curves in code. In this simple example a gradient is used to color the object and a curve is used to control the specular highlight.

Here is the final result:

<img src="/assets/images/docs/code-shader-example.png" height="auto" width="800" style="border-style:solid; border-color:darkgray; border-width:thick; border-radius:1vh" />

Here, the gradient is a very convenient way to control the color of the object. Simply by changing the gradient you can achieve a vast variety of different styles. For example, changing the gradient mode to "Fixed" you can achieve a nice toon shading look.

The bright yellow spot on the vase is the specular highlight. With one curve we've added lots of control over over it: we can control the intensity of the highlight, its size and position of the highlight. Without the curve, we would have to expose all these parameters separately, and would have to hard-code rigid math into the shader itself. This is why curves are a very powerful tool in shaders.

Here is the shader code for this example:

{::options parse_block_html="true" /}
<div class="text-small">
```hlsl
Shader "Surface"
{
    Properties
    {
        [Gradient] _BaseGradient("Color", 2D) = "white" {}
        [Curve] _SpecularCurve("Specular", 2D) = "white" {}
    }

    SubShader
    {
        Tags
        {
            "RenderType" = "Opaque" "RenderPipeline" = "UniversalPipeline"
        }

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Assets/Chroma/Core/HLSL/Chroma.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
                half3 normalOS : NORMAL;
            };

            struct Varyings
            {
                float4 positionHCS : SV_POSITION;
                float3 positionWS : TEXCOORD0;
                half3 normalWS : TEXCOORD1;
            };

            GRADIENT(_BaseGradient);
            CURVE(_SpecularCurve);

            Varyings vert(Attributes IN) {
                Varyings OUT;
                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.positionWS = TransformObjectToWorld(IN.positionOS);
                OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                const half3 lightDirection = GetMainLight().direction;
                const half nDotL = dot(IN.normalWS, lightDirection) * 0.5 + 0.5;
                const half4 color = SAMPLE_GRADIENT(_BaseGradient, nDotL);

                const half3 viewDirection = GetWorldSpaceNormalizeViewDir(IN.positionWS);
                const half3 reflection = reflect(-lightDirection, IN.normalWS);
                const half rDotV = dot(reflection, viewDirection);
                const half specular = SAMPLE_CURVE(_SpecularCurve, rDotV);
                const half4 specularColor = half4(GetMainLight().color * specular, 1);

                return color + specularColor;
            }
            ENDHLSL
        }
    }
}
```
</div>
{::options parse_block_html="false" /}

As you can see, the shader is very simple. Here's a small breakdown:
- First, it uses the [`[Gradient]`](/shader-ui-attributes/#gradient) and [`[Curve]`](/shader-ui-attributes/#curve) attributes to add shader parameters.
- Then it uses `GRADIENT` and `CURVE` macros to declare the gradient and curve properties.
- Finally, it uses the `SAMPLE_GRADIENT` and `SAMPLE_CURVE` macros to sample the gradient and curve properties.

That's it! You can now use gradients and curves in your shaders.
